# 34 | Nginx：高性能的Web服务器
## 进程池
Nginx 则完全不同，“一反惯例”地没有使用多线程，而是使用了“==进程池 + 单线程==”的工作模式。

Nginx 在启动的时候会预先创建好固定数量的 worker 进程，在之后的运行过程中不会再 fork 出新进程，这就是进程池，而且可以自动把进程“绑定”到独立的 CPU 上，这样就完全消除了进程创建和切换的成本，能够充分利用多核 CPU 的计算能力。

## I/O 多路复用
Nginx 里使用的 epoll，就好像是 HTTP/2 里的“多路复用”技术，它把多个 HTTP 请求处理打散成碎片，都“复用”到一个单线程里，不按照先来后到的顺序处理，而是只当连接上真正可读、可写的时候才处理，如果可能发生阻塞就立刻切换出去，处理其他的请求。

这里我画了一张 Nginx“I/O 多路复用”的示意图，你可以看到，它的形式与 HTTP/2 的流非常相似，每个请求处理单独来看是分散、阻塞的，但因为都复用到了一个线程里，所以资源的利用率非常高。
![title](https://raw.githubusercontent.com/Elingering/note-images/master/gitnote/2020/04/03/Snipaste_2020-04-03_11-54-51-1585886148265.png)

epoll 还有一个特点，大量的连接管理工作都是在操作系统内核里做的，这就减轻了应用程序的负担

## 多阶段处理
Nginx 的 HTTP 处理有四大类模块：
1. handler 模块：直接处理 HTTP 请求；
2. filter 模块：不直接处理请求，而是加工过滤响应报文；
3. upstream 模块：实现反向代理功能，转发请求到其他服务器；
4. balance 模块：实现反向代理时的负载均衡算法。

下面的这张图显示了 Nginx 的“流水线”，在 Nginx 里的术语叫“阶段式处理”（Phases），一共有 11 个阶段，每个阶段里又有许多各司其职的模块。





# 35 | OpenResty：更灵活的Web服务器

# 36 | WAF：保护我们的网络服务

# 37 | CDN：加速我们的网络服务

# 38 | WebSocket：沙盒里的TCP