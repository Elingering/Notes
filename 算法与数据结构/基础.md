# 05 | 数组：为什么很多编程语言中数组都从0开始编号？
## 如何实现随机访问？
数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

第一是==线性表==（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。
![title](https://raw.githubusercontent.com/Elingering/note-images/master/gitnote/2020/04/10/Snipaste_2020-04-10_10-42-28-1586491113296.png)
而与它相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。
![title](https://raw.githubusercontent.com/Elingering/note-images/master/gitnote/2020/04/10/Snipaste_2020-04-10_10-42-35-1586491120249.png)
第二个是==连续的内存空间和相同类型的数据==。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。

链表适合插入、删除，时间复杂度 O(1)；数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)

## 低效的“插入”和“删除”
数组有序，插入的时间复杂度为O(n);
插入到数组末尾时间复杂度为O(1);
数组无序，插入到某个位置：把该位置的元素插入到末尾，新元素替换该位置的元素时间复杂度为O(1)；

删除也要保证数据的连续性，为了避免数据会被搬移多次次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。

## 警惕数组的访问越界问题

## Tips
函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。

# 06 | 链表（上）：如何实现LRU缓存淘汰算法?
## 五花八门的链表结构
链表并不需要一块连续的内存空间，它通过“指针”将一组==零散的内存块==串联起来

三种最常见的链表结构，它们分别是：==单链表、双向链表和循环链表==。

## 链表 VS 数组性能大比拼
如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。

# 07 | 链表（下）：如何轻松写出正确的链表代码？
## 技巧一：理解指针或引用的含义
将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

## 技巧二：警惕指针丢失和内存泄漏
操作结点时，一定要注意操作的顺序

## 技巧三：利用哨兵简化实现难度
针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。

还记得如何表示一个空链表吗？head=null 表示链表中没有结点了。其中 head 表示头结点指
针，指向链表中的第一个结点。
如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。

我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。

哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。

## 技巧四：重点留意边界条件处理
