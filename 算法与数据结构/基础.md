# 05 | 数组：为什么很多编程语言中数组都从0开始编号？
## 如何实现随机访问？
数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

第一是==线性表==（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。
![title](https://raw.githubusercontent.com/Elingering/note-images/master/gitnote/2020/04/10/Snipaste_2020-04-10_10-42-28-1586491113296.png)
而与它相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。
![title](https://raw.githubusercontent.com/Elingering/note-images/master/gitnote/2020/04/10/Snipaste_2020-04-10_10-42-35-1586491120249.png)
第二个是==连续的内存空间和相同类型的数据==。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。

链表适合插入、删除，时间复杂度 O(1)；数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)

## 低效的“插入”和“删除”
数组有序，插入的时间复杂度为O(n);
插入到数组末尾时间复杂度为O(1);
数组无序，插入到某个位置：把该位置的元素插入到末尾，新元素替换该位置的元素时间复杂度为O(1)；

删除也要保证数据的连续性，为了避免数据会被搬移多次次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。

## 警惕数组的访问越界问题

## Tips
函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。

# 06 | 链表（上）：如何实现LRU缓存淘汰算法?
## 五花八门的链表结构
链表并不需要一块连续的内存空间，它通过“指针”将一组==零散的内存块==串联起来

三种最常见的链表结构，它们分别是：==单链表、双向链表和循环链表==。

## 链表 VS 数组性能大比拼
如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。

# 07 | 链表（下）：如何轻松写出正确的链表代码？
## 技巧一：理解指针或引用的含义
将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

## 技巧二：警惕指针丢失和内存泄漏
操作结点时，一定要注意操作的顺序

## 技巧三：利用哨兵简化实现难度
针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。

还记得如何表示一个空链表吗？head=null 表示链表中没有结点了。其中 head 表示头结点指
针，指向链表中的第一个结点。

如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。

我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。

哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。
![title](https://raw.githubusercontent.com/Elingering/note-images/master/gitnote/2020/04/10/Snipaste_2020-04-10_12-22-03-1586492537783.png)

## 技巧四：重点留意边界条件处理
我经常用来检查链表代码是否正确的边界条件有这样几个：
- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

## 技巧五：举例画图，辅助思考
## 技巧六：多写多练，没有捷径
- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第 n 个结点
- 求链表的中间结点

# 08 | 栈：如何实现浏览器的前进和后退功能？
## 如何理解“栈”？
叠盘子，==后进者先出，先进者后出，这就是典型的“栈”结构==。栈是一种“操作受限”的线性表

## 如何实现一个“栈”？
我们说==空间复杂度==的时候，是指除了**原本**的数据存储空间外，算法运行还需要**额外**的存储空间。

## 支持动态扩容的顺序栈
## 栈在函数调用中的应用
我们知道，操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构,用来存储函数调用时的**临时变量**。每进入一个**函数**，就会将临时变量作为一个栈帧**入栈**，当被调用函数执行完成，返回之后，将这个函数对应的栈帧**出栈**。

## 栈在表达式求值中的应用
实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。

如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。

## 栈在括号匹配中的应用
我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。

## Tips
内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。

内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。
- 代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。
- 静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。
- 栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。
- 堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。

# 09 | 队列：队列在线程池等有限资源池中的应用
## 如何理解“队列”？
先进者先出，这就是典型的“队列”。

## 顺序队列和链式队列
## 循环队列
最关键的是，==确定好队空和队满的判定条件==。

队空：head == tail
队满：(tail+1)%n=head

当队列满时，图中的 tail 指向的位置实际上是没有存储数据的。所以，循环队列会==浪费一个数组的存储空间==。

## 阻塞队列和并发队列
阻塞队列就是一个“生产者 - 消费者模型”！

==线程安全==的队列我们叫作并发队列。基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列（==无锁==）。

## Tips
实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。

# 10 | 递归：如何用三行代码找到“最终推荐人”？
## 如何理解“递归”？
去的过程叫“递”，回来的过程叫“归”。

## 递归需要满足的三个条件
1. 一个问题的解可以分解为几个子问题的解
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
3. 存在递归终止条件

## 如何编写递归代码？
==写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。==

==编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。==

## 递归代码要警惕堆栈溢出
我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。

## 递归代码要警惕重复计算
#image#
为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。

## 怎么将递归代码改写为非递归代码？
所有的递归代码都可以改为这种迭代循环的非递归写法

但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。

# 11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？
最经典的、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。
#image#

## 如何分析一个“排序算法”？
- 排序算法的执行效率
1. 最好情况、最坏情况、平均情况时间复杂度
2. 时间复杂度的系数、常数 、低阶
3. 比较次数和交换（或移动）次数（基于比较的排序算法）
- 排序算法的内存消耗
==原地排序==算法，就是特指空间复杂度是 O(1) 的排序算法。
- 排序算法的稳定性
如果待排序的序列中存在值**相等的元素**，经过排序之后，相等元素之间**原有的先后顺序不变**。

## 冒泡排序（Bubble Sort）
原地排序，稳定排序，时间复杂度O(n^2^)

有序度是数组中具有有序关系的元素对的个数。