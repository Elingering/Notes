# 10 | MySQL为什么有时候会选错索引？
我们平常不断地删除历史数据和新增数据，这时，MySQL 竟然会选错索引。

## 优化器的逻辑
而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。当然，**扫描行数**并不是唯一的判断标准，优化器还会结合是否使用**临时表**、是否**排序等**因素进行综合判断。

扫描行数是怎么判断的？
MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。

这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。

我们可以使用 show index 方法，看到一个索引的基数。
![title](https://raw.githubusercontent.com/Elingering/note-images/master/note-images/2019/07/16/1563254463067-1563254463096.png)
优化器为什么放着扫描 37000 行的执行计划不用，却选择了扫描行数是 100000 的执行计划呢？

这是因为，如果使用索引 a，每次从索引 a 上拿到一个值，都要回到主键索引上查出整行数据，这个代价优化器也要算进去的。

而如果选择扫描 10 万行，是直接在主键索引上扫描的，没有额外的代价。

优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执行时间看来，这个选择并不是最优的。

执行 analyze table t 命令重新统计索引信息
![title](https://raw.githubusercontent.com/Elingering/note-images/master/note-images/2019/07/16/1563255158333-1563255158344.png)

## 索引选择异常和处理
一种方法是，像我们第一个例子一样，采用 force index 强行选择一个索引。

第二种方法就是，我们可以考虑修改语句，引导 MySQL 使用我们期望的索引。

第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。

