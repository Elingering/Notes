# 37 | 什么时候会使用内部临时表
## union 执行流程
1. 创建一个内存临时表，这个临时表只有一个整型字段f，并且f是主键字段。
2. 执行第一个子查询，得到1000这个值，并存入临时表中。
3. 执行第二个子查询：
	- 拿到第一行id=1000，试图插入临时表中。但由于1000这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行；
	- 取到第二行id=999，插入临时表成功。
4. 从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是1000和999。

## group by 执行流程
1. 创建内存临时表，表里有两个字段m和c，主键是m；
2. 扫描表t1的索引a，依次取出叶子节点上的id值，计算id%10的结果，记为x；
	- 如果临时表中没有主键为x的行，就插入一个记录(x,1);
	- 如果表中有主键为x的行，就将x这一行的c值加1；
3. 遍历完成后，再根据字段m做排序，得到结果集返回给客户端。

## group by 优化方法 --索引
group by的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的id%100的结果是无序的，所以我们就需要有一个临时表，来记录并统计结果。

那么，如果扫描过程中可以保证出现的数据是有序的，是不是就简单了呢？

在MySQL 5.7版本支持了generated column机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列z，然后在z列上创建一个索引（如果是MySQL 5.6及之前的版本，你也可以创建普通列和索引，来解决这个问题）。
```sql
alter table t1 add column z int generated always as(id % 100), add index(z);
```

## group by优化方法 --直接排序
在group by语句中加入SQL_BIG_RESULT这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。

MySQL的优化器一看，磁盘临时表是B+树存储，存储效率不如数组来得高。所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。

**MySQL什么时候会使用内部临时表？**
1. 如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；
2. join_buffer是无序数组，sort_buffer是有序数组，临时表是二维表结构；
3. 如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如我们的例子中，union需要用到唯一索引约束， group by还需要用到另外一个字段来存累积计数。

## 小结
1. 如果对group by语句的结果没有排序要求，要在语句后面加 order by null；
2. 尽量让group by过程用上表的索引，确认方法是explain结果里没有Using temporary 和 Using filesort；
3. 如果group by需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大tmp_table_size参数，来避免用到磁盘临时表；
4. 如果数据量实在太大，使用SQL_BIG_RESULT这个提示，来告诉优化器直接使用排序算法得到group by的结果。

# 38 | 都说InnoDB好，那还要不要使用Memory引擎
## 内存表的数据组织结构
- InnoDB引擎把数据放在主键索引上，其他索引上保存的是主键id。这种方式，我们称之为==索引组织表==（Index Organizied Table）。
- 而Memory引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为==堆组织表==（Heap Organizied Table）。

## hash索引和B-Tree索引
实际上，内存表也是支B-Tree索引的。
不建议你在生产环境上使用内存表。这里的原因主要包括两个方面：
1. 锁粒度问题；
2. 数据持久化问题。

## 内存表的锁
内存表不支持行锁，只支持表锁。

## 数据持久性问题
数据放在内存中，是内存表的优势，但也是一个劣势。因为，数据库重启的时候，所有的内存表都会被清空。
在数据量可控，不会耗费过多内存的情况下，你可以考虑使用内存表。

内存临时表刚好可以无视内存表的两个不足，主要是下面的三个原因：
1. 临时表不会被其他线程访问，没有并发性的问题；
2. 临时表重启后也是需要删除的，清空数据这个问题不存在；
3. 备库的临时表也不会影响主库的用户线程。

# 39 | 自增主键为什么不是连续的
自增主键不能保证连续递增。
## 自增值保存在哪儿？
1. MyISAM引擎的自增值保存在数据文件中。
2. InnoDB引擎的自增值，其实是保存在了内存里。
- MySQL重启可能会修改一个表的AUTO_INCREMENT的值。
- 在MySQL 8.0版本，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值。

## 自增值修改机制
自增值不能回退。
- 唯一键冲突是导致自增主键id不连续的第一种原因。
- 事务回滚也会产生类似的现象，这就是第二种原因。
- 批量插入申请的id没用完。

## 自增锁的优化
在生产上，尤其是有insert … select这种批量插入数据的场景时，从并发插入数据性能的角度考虑，我建议你这样设置：innodb_autoinc_lock_mode=2（申请到自增id以后就立马释放自增锁），并且 binlog_format=row.这样做，既能提升并发性，又不会出现数据一致性问题。

需要注意的是，我这里说的==批量插入==数据，包含的语句类型是==insert … select、replace … select和load data语句==。

对于批量插入数据的语句，MySQL有一个批量申请自增id的策略：
1. 语句执行过程中，第一次申请自增id，会分配1个；
2. 1个用完以后，这个语句第二次申请自增id，会分配2个；
3. 2个用完以后，还是这个语句，第三次申请自增id，会分配4个；
4. 依此类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍。

# 40 | insert语句的锁为什么这么多
有些insert语句是属于“特殊情况”的，在执行过程中需要给其他资源加锁，或者无法在申请到自增id以后就立马释放自增锁。

## insert … select 语句
在可重复读隔离级别下，binlog_format=statement时：
需要对表t的所有行和间隙加锁，f

# 41 | 为什么临时表可以重名
# 42 | 为什么临时表可以重名
# 43 | 为什么临时表可以重名
# 44 | 为什么临时表可以重名
# 45 | 为什么临时表可以重名